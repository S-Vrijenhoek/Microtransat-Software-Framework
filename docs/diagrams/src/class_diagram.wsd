@startuml Class Diagram

interface ModuleBase
interface ModuleFactoryBase
interface ComputationBase
interface CoreBase

class ReadableModule
class WriteableModule
class Module
class ModuleFactory
class Computation
class Core
class Sensor
class Actuator
class Battery

ModuleBase <|.. Module
Module <|-- ReadableModule
Module <|-- WriteableModule
ReadableModule <|-- Sensor
ReadableModule <|-- Actuator
ReadableModule <|-- Battery
WriteableModule <|-- Actuator
ModuleFactoryBase <|.. ModuleFactory
ComputationBase <|.. Computation
CoreBase <|.. Core
Core - "1..*" ModuleBase
Core -left- "1" ModuleFactoryBase
Core -down- "1" ComputationBase

interface ModuleBase {
    - arbitration_id
}

interface CoreBase {
    + get_course_instructions()
    + set_module_data(arbitration_id, data)
}

interface ModuleFactoryBase {
    + create_modules()
}

interface ComputationBase {
    + compute_course_instructions()
}

class Module {
    + __eq__()
}

class Core {
    - modules
    - find_module_index(arbitration_id)
}

class ReadableModule {
    - data
}

class WriteableModule {
    - instructions
}

note left of ModuleFactoryBase::create_modules
    Modules need to be defined
    by their arbitation ID
    and module type inside 
    a settings file
end note

note right of Module::__eq__
    Compares arbitration IDs
    of both modules. This is
    used for testing purposes.
end note

@enduml